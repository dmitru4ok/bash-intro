#!/usr/bin/env bash
PATH=.
DICT=dict
ARRAY=array

mode=""
search_val=""
file_path=""


while getopts "k:v:" opt; do
    if [[ "$opt" == "k" ]]; then
        if [[ "$mode" == "value" ]]; then
            echo "-k and -v are mutually exclusive!"
            exit 1 
        fi
        mode="key"
        search_val="$OPTARG"
    elif [[ "$opt" == 'v' ]]; then
        if [[ "$mode" == "key" ]]; then
            echo  echo "-k and -v are mutually exclusive!"
            exit 1
        fi
        mode="value"
        search_val="$OPTARG"
    else echo "Usage: $0 ([-k key_path] | [-v value]) json_file"; exit 1;
    fi
done

shift $((OPTIND-1))
file_path="$1"
if [ -z "$file_path" ]; then
    echo "Usage: $0 ([-k key_path] | [-v value]) json_file"
    exit 65
fi

if [ -z "$mode" ]; then
    mode="key"
    echo "$1 $2"
    search_val="$1"
    file_path="$2"
fi

if [ ! -e "$file_path" ]; then 
    echo "File $file_path doesn't exist" 
    exit 66
fi

declare -a current_path
declare -a struct_stack

square_br_open=0
curly_br_open=0
double_q_open=0
read_what=data # key, data
inside_struct="n"
key_buffer=""
value_buffer=""
nex_val_matched=0

struct_state_push () {
    struct_stack+=("$inside_struct")
    if [ -n "$key_buffer" ]; then
        current_path+=("$key_buffer")
        key_buffer=""
    fi

    inside_struct=$1
}

struct_state_pop() {
    unset 'struct_stack[-1]'
    if [ "${#struct_stack[@]}" -gt 0 ]; then
        inside_struct="${struct_stack[-1]}"
    fi

    if [ "${#current_path[@]}" -gt 0 ]; then
        unset 'current_path[-1]'
    fi
}
 
while IFS='' read -r -n 1 char; do
    if [[ "$read_what" == "key" ]]; then # keys
        if [[ "$char" == '"' && "$double_q_open" -eq 1 ]]; then
            double_q_open=0

            concat_path=("${current_path[@]}" "$key_buffer")
            # echo "Curr path: ${current_path[@]}, curr+keybuff=${concat_path[*]}"
            if [[ "$mode" == "key" && "$search_val" == $(IFS='.' && echo "${concat_path[*]}") ]]; then
                nex_val_matched=1
            fi
            
        elif [[ "$char" == '"' ]]; then
            key_buffer=""
            double_q_open=1
        elif [[ "$double_q_open" -eq 1 ]]; then
            key_buffer+="$char"
        elif [[ "$char" == ":" ]]; then
            read_what=data
        fi
    else
        if [[ "$char" == '"' && "$double_q_open" -eq 1 ]]; then
            double_q_open=0
            if [[ "$mode" == "value" && "$search_val" == "$value_buffer" ]]; then
                echo "path $(IFS='.' && echo "${current_path[*]}") matched with val $value_buffer"
            elif [[ "$mode" == "key" && "$nex_val_matched" -eq 1 ]]; then
                echo "$(IFS='.' && echo "${current_path[*]}".$key_buffer) = $value_buffer"
                nex_val_matched=0
            fi
            value_buffer=""
        elif [[ "$char" == '"' ]]; then
            double_q_open=1
        elif [[ "$double_q_open" -eq 1 || "$char" =~ [-0-9] ]]; then
            value_buffer+="$char"
        elif [[ "$char" == "[" ]]; then
            ((square_br_open++))
            struct_state_push "$ARRAY"
        elif [[ "$char" == "]" ]]; then
            ((square_br_open--))
            struct_state_pop
        elif [[ "$char" == "{" ]]; then
            ((curly_br_open++))
            struct_state_push "$DICT"
            read_what=key
        elif [[ "$char" == "}" ]]; then
            ((curly_br_open--))
            struct_state_pop
        elif [[ "$char" == ',' ]]; then
            [[ "$inside_struct" == "$DICT" ]] && read_what=key
            if [[ "$mode" == "value" && "$search_val" == "$value_buffer" ]]; then
                echo "path $(IFS='.' && echo "${current_path[*]}".$key_buffer) = $value_buffer"
            elif [[ "$mode" == "key" && "$nex_val_matched" -eq 1 ]]; then
                echo "$(IFS='.' && echo "${current_path[*]}".$key_buffer) = $value_buffer"
                nex_val_matched=0
            fi

            value_buffer=""
        fi
    fi
    # echo -e "Ch: $char | kb: $key_buffer | vb: $value_buffer | \": $double_q_open, stack: ${struct_stack[@]}"
done < "$file_path";

if ! [ "$square_br_open" -eq 0 -a "$curly_br_open" -eq 0 -a "$double_q_open" -eq 0 ]; then
    echo "Invalid JSON!"
    exit 1
fi
